{"version":3,"sources":["service-worker.js"],"names":["CACHE_NAME","RESOURCES_TO_PRELOAD","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","catch","error","console","keys","keyList","Promise","all","map","key","delete","request","method","url","indexOf","getCustomResponsePromise","log","location","match","cachedResponse","fetch","netResponse","put","clone","respondWith"],"mappings":";AAqCA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,MAAA,GAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,QAAA,QAAA,GAAA,KAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,WAAA,IAAA,EAAA,KAAA,EAAA,UAAA,OAAA,IAAA,QAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,OAAA,MArCA,IAAIA,EAAa,6BACbC,EAAuB,CACvB,cAIJC,KAAKC,iBAAiB,UAAW,SAAUC,GACvCA,EAAMC,UACFC,OAAOC,KAAKP,GAAYQ,KAAK,SAAUC,GAC5BA,OAAAA,EAAMC,OAAOT,KAGrBU,MAAM,SAAUC,GACfC,QAAQD,MAAMA,QAM1BV,KAAKC,iBAAiB,WAAY,SAAUC,GACxCA,EAAMC,UACFC,OAAOQ,OAAON,KAAK,SAAUO,GAClBC,OAAAA,QAAQC,IAAIF,EAAQG,IAAI,SAAUC,GACjCA,GAAAA,IAAQnB,EACDM,OAAAA,OAAOc,OAAOD,WAazCjB,KAAKC,iBAAiB,QAAS,SAAAC,GACvBA,GAAyB,QAAzBA,EAAMiB,QAAQC,QAA2D,IAAvClB,EAAMiB,QAAQE,IAAIC,QAAQ,SAA5DpB,CAGEqB,IAAAA,EAAwB,WAAA,IAAA,EAAA,EAAG,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EAExBrB,GADLS,QAAQa,IAAWtB,OAAAA,OAAAA,EAAMiB,QAAQE,KAA0BI,mBAAAA,OAAAA,WACf,IAAvCvB,EAAMiB,QAAQE,IAAIC,QAAQ,SAFF,CAAA,EAAA,KAAA,GAAA,MAKQlB,OALR,EAAA,KAAA,EAAA,EAAA,KAAA,EAKQA,OAAOsB,MAAMxB,EAAMiB,SAL3B,KAAA,EAMjBQ,KADEA,EALe,EAAA,MAAA,CAAA,EAAA,KAAA,EAAA,MASVA,OADPhB,QAAQa,IAAuBG,mBAAAA,OAAAA,IACxBA,EAAAA,OAAAA,SAAAA,GATU,KAAA,EAaKC,OAbL,EAAA,KAAA,GAaKA,MAAM1B,EAAMiB,SAbjB,KAAA,GAiBHf,OAJZyB,EAbe,EAAA,KAcrBlB,QAAQa,IAda,gCAAA,EAAA,KAAA,GAiBHpB,OAAOC,KAAKP,GAjBT,KAAA,GAuBd+B,OAvBc,EAAA,KAoBfC,IAAI5B,EAAMiB,QAASU,EAAYE,SAG9BF,EAAAA,OAAAA,SAAAA,GAvBc,KAAA,GAAA,MAAA,EAAA,KAAA,GAAA,EAAA,GAAA,EAAA,MAAA,GAyBrBlB,QAAQD,MAAR,SAAA,OAAA,EAAA,KAzBqB,EAAA,GAAA,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA,EAAA,SAA3Ba,OAAAA,WAAwB,OAAA,EAAA,MAAA,KAAA,YAAA,GAiC9BrB,EAAM8B,YAAYT","file":"service-worker.map","sourceRoot":"..\\public","sourcesContent":["var CACHE_NAME = 'pwa-xviewers-asset-cache-0';\r\nvar RESOURCES_TO_PRELOAD = [\r\n    'index.html'\r\n];\r\n\r\n// Preload some resources during install\r\nself.addEventListener('install', function (event) {\r\n    event.waitUntil(\r\n        caches.open(CACHE_NAME).then(function (cache) {\r\n            return cache.addAll(RESOURCES_TO_PRELOAD);\r\n            // if any item isn't successfully added to\r\n            // cache, the whole operation fails.\r\n        }).catch(function (error) {\r\n            console.error(error);\r\n        })\r\n    );\r\n});\r\n\r\n// Delete obsolete caches during activate\r\nself.addEventListener('activate', function (event) {\r\n    event.waitUntil(\r\n        caches.keys().then(function (keyList) {\r\n            return Promise.all(keyList.map(function (key) {\r\n                if (key !== CACHE_NAME) {\r\n                    return caches.delete(key);\r\n                }\r\n            }));\r\n        })\r\n    );\r\n});\r\n/**\r\n * The fetch event is fired every time the browser sends a request. \r\n * In this case, the service worker acts as a proxy. We can for example return the cached\r\n * version of the ressource matching the request, or send the request to the internet\r\n * , we can even make our own response from scratch !\r\n * Here, we are going to use cache first strategy\r\n */\r\nself.addEventListener('fetch', event => {\r\n    if (event.request.method !== 'GET' || event.request.url.indexOf('https') !== 0) return;\r\n    //We defind the promise (the async code block) that return either the cached response or the network one\r\n    //It should return a response object\r\n    const getCustomResponsePromise = async function () {\r\n        console.log(`URL ${event.request.url}`, `location origin ${location}`)\r\n        if ((event.request.url.indexOf('https') === 0)) {\r\n            try {\r\n                //Try to get the cached response\r\n                const cachedResponse = await caches.match(event.request)\r\n                if (cachedResponse) {\r\n                    //Return the cached response if present\r\n                    console.log(`Cached response ${cachedResponse}`)\r\n                    return cachedResponse\r\n                }\r\n\r\n                //Get the network response if no cached response is present\r\n                const netResponse = await fetch(event.request)\r\n                console.log(`adding net response to cache`)\r\n\r\n                //Here, we add the network response to the cache\r\n                let cache = await caches.open(CACHE_NAME)\r\n\r\n                //We must provide a clone of the response here\r\n                cache.put(event.request, netResponse.clone())\r\n\r\n                //return the network response\r\n                return netResponse\r\n            } catch (err) {\r\n                console.error(`Error ${err}`)\r\n                throw err\r\n            }\r\n        }\r\n    };\r\n\r\n    //In order to override the default fetch behavior, we must provide the result of our custom behavoir to the\r\n    //event.respondWith method\r\n    event.respondWith(getCustomResponsePromise())\r\n});"]}