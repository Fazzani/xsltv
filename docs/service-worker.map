{"version":3,"sources":["service-worker.js"],"names":["CACHE_NAME","RESOURCES_TO_PRELOAD","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","catch","error","console","keys","keyList","Promise","all","map","key","delete","request","method","url","indexOf","getCustomResponsePromise","log","location","match","cachedResponse","fetch","netResponse","put","clone","respondWith"],"mappings":"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","file":"service-worker.map","sourceRoot":"..\\public","sourcesContent":["var CACHE_NAME = 'pwa-xviewers-asset-cache-0';\r\nvar RESOURCES_TO_PRELOAD = [\r\n    'index.html'\r\n];\r\n\r\n// Preload some resources during install\r\nself.addEventListener('install', function (event) {\r\n    event.waitUntil(\r\n        caches.open(CACHE_NAME).then(function (cache) {\r\n            return cache.addAll(RESOURCES_TO_PRELOAD);\r\n            // if any item isn't successfully added to\r\n            // cache, the whole operation fails.\r\n        }).catch(function (error) {\r\n            console.error(error);\r\n        })\r\n    );\r\n});\r\n\r\n// Delete obsolete caches during activate\r\nself.addEventListener('activate', function (event) {\r\n    event.waitUntil(\r\n        caches.keys().then(function (keyList) {\r\n            return Promise.all(keyList.map(function (key) {\r\n                if (key !== CACHE_NAME) {\r\n                    return caches.delete(key);\r\n                }\r\n            }));\r\n        })\r\n    );\r\n});\r\n/**\r\n * The fetch event is fired every time the browser sends a request. \r\n * In this case, the service worker acts as a proxy. We can for example return the cached\r\n * version of the ressource matching the request, or send the request to the internet\r\n * , we can even make our own response from scratch !\r\n * Here, we are going to use cache first strategy\r\n */\r\nself.addEventListener('fetch', event => {\r\n    if (event.request.method !== 'GET' || event.request.url.indexOf('https') !== 0) return;\r\n    //We defind the promise (the async code block) that return either the cached response or the network one\r\n    //It should return a response object\r\n    const getCustomResponsePromise = async function () {\r\n        console.log(`URL ${event.request.url}`, `location origin ${location}`)\r\n        if ((event.request.url.indexOf('https') === 0)) {\r\n            try {\r\n                //Try to get the cached response\r\n                const cachedResponse = await caches.match(event.request)\r\n                if (cachedResponse) {\r\n                    //Return the cached response if present\r\n                    console.log(`Cached response ${cachedResponse}`)\r\n                    return cachedResponse\r\n                }\r\n\r\n                //Get the network response if no cached response is present\r\n                const netResponse = await fetch(event.request)\r\n                console.log(`adding net response to cache`)\r\n\r\n                //Here, we add the network response to the cache\r\n                let cache = await caches.open(CACHE_NAME)\r\n\r\n                //We must provide a clone of the response here\r\n                cache.put(event.request, netResponse.clone())\r\n\r\n                //return the network response\r\n                return netResponse\r\n            } catch (err) {\r\n                console.error(`Error ${err}`)\r\n                throw err\r\n            }\r\n        }\r\n    };\r\n\r\n    //In order to override the default fetch behavior, we must provide the result of our custom behavoir to the\r\n    //event.respondWith method\r\n    event.respondWith(getCustomResponsePromise())\r\n});"]}